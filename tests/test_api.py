from unittest.mock import create_autospec

import flask
import pytest
from werkzeug import exceptions


SPOONACULAR_BASE = "https://api.spoonacular.com/recipes/"
ENDPOINT_MAP = (("api.search_api", "complexSearch"),
                ("api.ingredient_api", "parseIngredients"))


@pytest.mark.parametrize("endpoint,spoonacular_endpoint", ENDPOINT_MAP)
def test_endpoints_success(client, requests_mock, endpoint, spoonacular_endpoint):
    """On success, Spoonacular's response should be forwarded with a 200 status code."""
    data = dict(hello="world")
    requests_mock.get(SPOONACULAR_BASE + spoonacular_endpoint, json=data)

    res = client.get(flask.url_for(endpoint))

    assert res.status_code == 200
    assert res.get_json() == data


@pytest.mark.parametrize("endpoint,spoonacular_endpoint", ENDPOINT_MAP)
@pytest.mark.options(SPOONACULAR_KEY="test_key")
def test_args_forwarded(client, requests_mock, endpoint, spoonacular_endpoint):
    """Arguments should be forwarded to the Spoonacular request and the API key should be passed."""
    requests_mock.get(SPOONACULAR_BASE + spoonacular_endpoint, json={})

    client.get(flask.url_for(endpoint, hello="world"))

    # qs is generated by urllib.parse.parse_qs, which puts values in lists.
    assert requests_mock.last_request.qs == dict(
        apikey=["test_key"], hello=["world"])


@pytest.mark.parametrize("endpoint,spoonacular_endpoint", ENDPOINT_MAP)
def test_spoonacular_error_forwarded(client, requests_mock, endpoint, spoonacular_endpoint):
    """Response and status code should be forwarded from Spoonacular upon failure."""
    data = dict(
        status="failure",
        code=401,
        message="You are not authorized. Please read ...",
    )
    requests_mock.get(
        SPOONACULAR_BASE + spoonacular_endpoint,
        json=data,
        status_code=data["code"],
        headers={"content-type": "application/json"},
    )

    res = client.get(flask.url_for(endpoint))

    assert res.status_code == data["code"]
    assert res.get_json() == data


@pytest.mark.parametrize("endpoint", ("api.search_api", "api.ingredient_api"))
@pytest.mark.parametrize("error", (exceptions.BadRequest(), exceptions.InternalServerError()))
def test_error_json_response(client, endpoint, error):
    """Errors should return responses in JSON."""
    client.application.view_functions[endpoint] = create_autospec(
        client.application.view_functions[endpoint], spec_set=True, side_effect=error
    )

    res = client.get(flask.url_for(endpoint))

    assert res.status_code == error.code
    assert res.get_json() == dict(
        status="failure",
        code=error.code,
        message=f"{error.name}: {error.description}",
    )


@pytest.mark.parametrize("param", ("fillIngredients", "addRecipeNutrition"))
@pytest.mark.parametrize("value,expected_status", (("true", 403), ("false", 200)))
def test_search_disabled_params(client, requests_mock, param, value, expected_status):
    """Search endpoint should return 403 when disabled params are true, and 200 when false."""
    requests_mock.get(SPOONACULAR_BASE + "complexSearch", json={})

    res = client.get(flask.url_for("api.search_api", **{param: value}))

    assert res.status_code == expected_status


@pytest.mark.parametrize(
    "endpoint,spoonacular_endpoint,limit",
    ((*ENDPOINT_MAP[0], 1), (*ENDPOINT_MAP[1], 15)),
)
def test_rate_limits(client, requests_mock, endpoint, spoonacular_endpoint, limit):
    """Endpoints should be rate limited."""
    requests_mock.get(SPOONACULAR_BASE + spoonacular_endpoint, json={})

    for _ in range(limit):
        # A new context is needed to clear flask.g because flask-limiter stores state there.
        with client.application.app_context():
            res = client.get(flask.url_for(endpoint))
            assert res.status_code == 200

    res = client.get(flask.url_for(endpoint))
    assert res.status_code == 429
